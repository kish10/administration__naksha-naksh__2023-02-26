# Checklist - MVP - Feature - Ability to create an arbitrary form

## Rough version while learning phoenix -- JS Only

1. Use Javascript to create an array of form fields in "Edit Mode" (for client side storage & updating -- to avoid unnecessary server calls)
  - Can do this either with "LiveView JS" or "Alpine JS", whichever is appropriate & easier


2. Display form fields in "Edit mode" from the Javascript array of form fields.
  - *2023-03-08 - 7:20*:
    - Rendered the name of a form field using Alpine.js, based on a `formField` list created using Alpine's `x-data`
    - Next step:
      - Thinking about how to deal with `measurement_type`
        - Update - Thoughts:
          - Issue is that, `measurement_type` has special meaning, it is a value within a set of values
            - So need to have this connection/context in both JS & Elixir, wherever necesarry
              - Want `measurement_type` options in JS be generated by an Elixir Enum
              - Want the `measurementType` in a JS `formField` object to be easily mapable to Elixir
      - Create the HTML UI that displays the `formFields` already in the `formFields` array
        - For now can create a JS object that holds the possible `measurement_type` values
          - In future, use an Elixir enum, that Alpine.js pulls from
  - *2023-03-08 - 7:54*:
    - Started refactoring the code, to display "form fields" based on the "formField" array in "Edit mode" rendered through Alpine.js.
      - In particular:
        - Created an appopriate `<div role="list" ...>` to render the `formField` list while being ARIA complaint.
        - Created a JS object for `measurementTypes` to hold the set of "measerement types" that can be referenced within the `formField` JS object.
    - Next step:
      - Make the measurement `name` HTML input
      - Create the whole element of a "form field" in "Edit mode", with an `input` to specify the name, and a text for the "measurement_type"
        - In future can make "measurement_type" editable with a drop down, or an "Edit mode" for the whole "form field"
  - *2023-03-08 - ~19:00*:
    - Made the measurement `name` into an HTML input
    - Created the whole element of a "form field" in "Edit mode", with an `input` to specify the name, and a text for the "measurement_type"

  - *2023-03-10 - 8:04*:
    - Completed rough (client side) "Form field" UI in "Edit Mode"
      - So can edit:
        - The field name
        - The type of measurement (without data type conversions & checks -- just buttons & updating client side JS store)
    - Next steps:
      - Set up Postgress for data storage
      - Set up Ecto for database interactions
      - Create database schema for "Application" elements
      - Create database table (within "Appplication" elements) schema for "Manual Data Form Fields"
      - Populate form fields from a server side storage (retrieved from the "Manual Data Form Fields" table)
      - Send updates to server for server side storage

2. (2.1). Display form fields in "Edit mode" from the Javascript array of form fields. -- Make the "measurement_type" editable
  - Steps:
    - Create a dropdown button for the edit.
    - When dropdown clicked, open "selection menu"
      - Can be a dropdown menu or a "div" that is shown with the options
      - The current measurement_type should be indicated
      - Buttons should be provided for the different options


3. Make "Add a new field" button functional, so that click in results in:
  - The Javascript array of form fields being updated with a new empty form field
  - A HTML UI element is created where the user can enter the `name` & `measurement_type` of the new form field

## Rough version while learning Phoenix -- Persist form field information server side also

- So edits on the client-side are pushed to server-side
  - Note:
    - To avoid unnecessary server calls, deciding not to only store form field information on the server -- so not pull from the server at this stage -- just pushing into the server

- (Bonus) Find a way where don't have to repeat JS & Elixir code -- Ex: Having to define the same enums in both JS & Elixir


## Next steps ideas

- Create a "store" for tracking form fields:
  - Can be an application "state" created using Elixir Processes (https://elixir-lang.org/getting-started/processes.html#state)

